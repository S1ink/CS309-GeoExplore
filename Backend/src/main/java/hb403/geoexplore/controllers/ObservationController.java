package hb403.geoexplore.controllers;

import hb403.geoexplore.datatype.map.items.EventEntity;
import hb403.geoexplore.datatype.map.items.ObservationEntity;
import hb403.geoexplore.datatype.map.items.ObservationRepository;
import hb403.geoexplore.util.GeometryUtil;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;

@RestController
public class ObservationController {

    @Autowired
    protected ObservationRepository obsRepo;

    //C of Crudl, adds observation to repo
    @PostMapping(path = "geomap/observations")
    public @ResponseBody ObservationEntity.JsonFormat saveObs(@RequestBody ObservationEntity.JsonFormat obs_json){
        if (obs_json != null){
             ObservationEntity saved = ObservationEntity.fromJson(obs_json);
            saved.nullId();
            final ObservationEntity returning = obsRepo.save(saved);
            return ObservationEntity.formatJson(returning);

        }
        else {
            return null;
        }
    }


    //R of Crudl gets observation from repo
    @GetMapping(path = "geomap/observations/{id}")
    public @ResponseBody ObservationEntity.JsonFormat getObs(@PathVariable Long id) {
        if (id != null) {
        return ObservationEntity.formatJson(this.obsRepo.findById(id).get());
        } else {
            return null;
        }
    }


    @PutMapping(path = "geomap/observations/{id}")
    public @ResponseBody ObservationEntity.JsonFormat updateObs(@PathVariable Long id,@RequestBody ObservationEntity.JsonFormat obs_json){
        if (id != null && obs_json != null){
                obs_json.setId(id);
                final ObservationEntity saved = this.obsRepo.save(ObservationEntity.fromJson(obs_json));
                saved.setId(id);
                return ObservationEntity.formatJson(saved);
        }
        else {
            return null;
        }
    }

    @DeleteMapping(path = "geomap/observations/{id}")
    public @ResponseBody ObservationEntity.JsonFormat deleteObs(@PathVariable Long id){
        if (id != null){
            final ObservationEntity.JsonFormat ref = this.getObs(id);
            this.obsRepo.deleteById(id);
            return ref;
        }
        else {
            return null;
        }
    }

    @GetMapping(path = "geomap/observations")
    public List<ObservationEntity.JsonFormat> getAllObs(){
        final List<ObservationEntity> obs = this.obsRepo.findAll();
        final ArrayList<ObservationEntity.JsonFormat> formatted = new ArrayList<>();
        for (ObservationEntity o :obs){
            formatted.add(ObservationEntity.formatJson(o));
        }
        return formatted;
    }


    /** Returns the list of events within the bounds generated by the provided WKT geometry string */
	@GetMapping(path = "geomap/observations/within")
	public @ResponseBody List<ObservationEntity.JsonFormat> getObservationsWithinBounds(@RequestBody String wkt_bounds_geom) {	// takes in 'well known text' for the bounding geometry --> may define special json formats for predefined bounds later
		try {
			final List<ObservationEntity> bounded = this.obsRepo.findWithin( GeometryUtil.getGeometry(wkt_bounds_geom) );
			System.out.println("Recieved " + bounded.size() + " bounded events");
			final ArrayList<ObservationEntity.JsonFormat> formatted = new ArrayList<>();
			for(ObservationEntity o : bounded) {
				formatted.add(ObservationEntity.formatJson(o));
			}
			return formatted;
		} catch(Exception e) {
			System.out.println("ObservationEntity.getObservationsWithinBounds(): Encountered exception! -- " + e.getMessage());
			// continue >>> (return null)
		}
		return null;
	}


}
